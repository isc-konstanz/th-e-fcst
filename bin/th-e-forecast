#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
    th-e-forecast
    ~~~~~
    
"""
import logging.config

import sys
import os
from boto import config
from pygments.lexers import configs
from theforecast.database import CsvDatabase
sys.path.insert(0, os.path.dirname(os.path.abspath(sys.argv[0])))

from argparse import ArgumentParser
from configparser import ConfigParser
import json
import shutil
import inspect
import matplotlib.pyplot as plt
from keras.models import load_model
import numpy as np
import time
from scipy import signal
import os
from scipy import signal
from theforecast import processing

    
def main(rundir, args=None):
    from theforecast import Forecast, ForecastException
    from theforecast.neuralnetwork import NeuralNetwork
    from theforecast.io_control import IO_control
    
    if args.configs != None:
        configs = args.configs
        logger.debug('System configurations will be read in from "%s"', configs)
    else:
        configs = os.path.join(rundir, 'conf')
        
    # Parameter and variables:
    prediction_stack = np.zeros([3, 0])
    IO_hist = np.zeros(1440)
    n_training_days = 30
    n_input_days = 7
    pred_start = 50 * 1440
    f_prediction = 5
    f_retrain = 6 * 60
    horizon_0 = 144
    charge = 80
    b, a = signal.butter(8, 0.1)  # lowpass filter of order = 8 and critical frequency = 0.1 (-3dB)

    system = Forecast(configs)
    control = IO_control(system.neuralnetwork.fMin, f_prediction)
    data = system.databases['CSV'].data
    i_start = (n_training_days - n_input_days) * 1440
    
    fig, axs = plt.subplots(2, 1)
    mng = plt.get_current_fig_manager()
    plt.pause(.1)
    mng.window.showMaximized()
    
#     data_training = [data[0][i_start:],  # BI
#                     data[1][i_start:]]  # timestamp
#         
#     X, Y = system.neuralnetwork.getInputVector(data_training,
#                                                system.neuralnetwork.lookBack,
#                                                system.neuralnetwork.lookAhead,
#                                                system.neuralnetwork.fMin,
#                                                training=True)
#    
#     system.neuralnetwork.model.fit(X, Y[:, 0, :], epochs=1, batch_size=64, verbose=2)
#     system.neuralnetwork.model.save('myModel')
    system.neuralnetwork.model = load_model('myModel')

#     system.neuralnetwork.model = load_model('myModel')
#     system.neuralnetwork.model = load_model('myModelInit')
    
#     system.neuralnetwork.model.fit(X, Y[:, 0, :], epochs=3, batch_size=64, verbose=2)
#     system.neuralnetwork.model.save('myModelInit')
#     try:
#         model = load_model('myModel')
#         if model.get_config() == system.neuralnetwork.model.get_config():
#             system.neuralnetwork.model = model
#         elif model.get_config() != system.neuralnetwork.model.get_config():
#             system.neuralnetwork.model.fit(X, Y[:, 0, :], epochs=4, batch_size=64, verbose=2)
#             system.neuralnetwork.model.save('myModel')
#         # system.neuralnetwork.model.save('myModel')
#     except (OSError) as e:
#         system.neuralnetwork.model.fit(X, Y, epochs=8, batch_size=64, verbose=2)
#         system.neuralnetwork.model.save('myModel')
#         logger.error('No model found. Import error: %s', str(e))
    k = 0
    while True:           
        try:
            print('Iteration: ' + str(k))
            horizon = horizon_0 - int(k / f_prediction)
            
            input_vector, prediction = system.execute(pred_start, k, f_retrain)
            processing.plot_prediction(axs, system, input_vector, prediction, k, pred_start)
            prediction_mean = signal.filtfilt(b, a, prediction, padlen=150)[:horizon]
            
            control.pred_horizon = horizon 
            control.u_init = IO_hist[-2:]
            control.charge_energy_amount = charge - sum(IO_hist)
            control.prediction = prediction_mean[:horizon]
            
            if control.charge_energy_amount >= 0.1:
                control.get_IO()
                IO_actual = control.IO_control
            elif control.charge_energy_amount < 0.1:
                IO_actual = np.zeros(f_prediction)
                
            IO_hist = np.roll(IO_hist, -f_prediction)
            IO_hist[-f_prediction:] = IO_actual[:f_prediction]
    
            processing.plot_IO_control(axs, IO_hist, control, k, f_prediction)
            plt.savefig('plots\\fig_' + str(k))
            
        except (ForecastException) as e:
            logger.error('Fatal forecast error: %s', str(e))
            sys.exit(1)  # abnormal termination

        k = k + f_prediction
        time.sleep(.1)
    
    print(' --- END of SIMULATION --- ')
    system.neuralnetwork.model.save('myModel_FinalLTS')
    os.system('shutdown -s')
    sys.exit(0)  # successful termination


if __name__ == '__main__':

    rundir = os.path.dirname(os.path.abspath(inspect.getsourcefile(main)))
    if os.path.basename(rundir) == 'bin':
        rundir = os.path.dirname(rundir)
    
    # Load the logging configuration
    logging.config.fileConfig(os.path.join(rundir, 'conf', 'logging.cfg'))
    logger = logging.getLogger('th-e-forecast')
    
    parser = ArgumentParser(description=__doc__)
    parser.add_argument('-c', '--configs',
                        dest='configs',
                        help='Directory of system configuration files',
                        metavar='DIR')
    
    main(rundir, args=parser.parse_args())
    
